# 树莓派拉取视频流

目标：在树莓派 4B 上同时驱动 OV9281（120FPS 高速可见光）和 Tiny1-C（热成像），并解决帧率低、画面重影、程序卡死等问题。

> 效果演示
>
> 热成像卡顿是因为会在一段时间内关闭快门自动校正，防止因为自身热量造成图像失真

![](./images/树莓派拉取视频流演示.gif)

------

## 一、 硬件架构与连接

为了满足 **1280x800 @ 120FPS** 的数据吞吐量，硬件连接必须严格遵循物理带宽分配：

1. **计算平台**：Raspberry Pi 4B (4GB/8GB)
2. **OV9281 (高速相机)**：必须连接 **USB 3.0 (蓝色接口)**。
   - *原因*：MJPG 120FPS 数据流巨大，USB 2.0 带宽不足会导致掉帧。
3. **Tiny1-C (热成像)**：必须连接 **USB 2.0 (黑色接口)**。
   - *原因*：避免与 OV9281 抢占 USB 3.0 总线控制权，防止报错 `uvc_camera_open:-6 (Device Busy)`。
4. **供电**：12V 锂电池 -> UBEC 降压模块 (5V 3A) -> 树莓派 GPIO/Type-C。
5. **显示**：HDMI 直连显示器（避免 X11 网络转发瓶颈）。

------

## 二、 核心问题与解决方案复盘

在开发过程中，我们依次解决了以下 5 个致命问题：

### 1. OV9281 帧率锁死在 40/50 FPS

- **现象**：代码设置了 120FPS，但实际运行只有 40fps 或 50fps。
- **原因**：
  1. **物理曝光限制**：默认自动曝光（Auto Exposure）在室内光线下会将快门拉长到 20ms~30ms，物理上限制了帧率上限（1000ms/25ms = 40fps）。
  2. **防闪烁干扰**：Linux 驱动默认开启 50Hz 防闪烁，强制对齐帧率。
- **解决方案**：
  - 使用 `v4l2-ctl` 强制关闭自动曝光。
  - 强制设置 **曝光时间 (Exposure Time Absolute)** 为 **20~80** (2ms~8ms)。
  - 强制关闭 **防闪烁 (Power Line Frequency)**。

### 2. OV9281 画面全黑

- **现象**：解锁 120FPS 后，画面一片漆黑。
- **原因**：为了高帧率强制将曝光时间压缩到了 2ms，进光量严重不足。
- **解决方案**：
  - 在驱动初始化时，将 **模拟增益 (Gain)** 拉升至 **200-255**（最大值）。
  - 测试时使用强光手电筒补光。

### 3. 热成像画面“六个重影/小格子”

- **现象**：热成像画面分裂成多段，像马赛克一样错位。
- **原因**：**内存对齐（Stride）错误**。Tiny1-C 输出的 YUV422 数据（每像素2字节）被错误地按 BGR888（每像素3字节）读取，或者内存宽度未进行 4 字节对齐。
- **解决方案**：
  - SDK 配置为 `OUTPUT_FMT_YUV422`。
  - 内存分配大小改为 `width * height * 2`。
  - 使用 OpenCV `cv::cvtColor(src, dst, COLOR_YUV2BGR_YUYV)` 进行正确的色彩空间转换。

### 4. 热成像运行 2 分钟后卡死

- **现象**：OV9281 继续运行，但热成像画面静止，程序无法正常退出。
- **原因**：
  1. SDK 示例代码中硬编码了 `stream_time = 100` 秒，时间到自动停止流。
  2. 多线程信号量（Semaphore）死锁：主循环只处理了图像信号，未及时释放温度信号 (`temp_sem`)，导致 SDK 内部采集线程挂起。
- **解决方案**：
  - 将 `stream_time` 设为 `999999`。
  - 在主循环中非阻塞检查并释放 `temp_sem`。

### 5. 编译报错 `conflicting declaration`

- **原因**：OpenCV 的 C++ 头文件被包含在了 `extern "C"` 块中，导致符号名修饰冲突。
- **解决方案**：重构 `sample.h`，将 OpenCV 头文件移出 `extern "C"` 作用域。

------

## 三、 最终版核心代码摘要

### 1. `OV9281_Driver.cpp` (原子化初始化)

这是实现 120FPS 的关键驱动。

C++

```
bool OV9281_Driver::init(int camera_id, int target_fps) {
    // 1. 原子化参数配置：在打开瞬间注入 MJPG 和 120FPS，防止回退到 YUYV
    std::vector<int> params = {
        cv::CAP_PROP_FOURCC, cv::VideoWriter::fourcc('M', 'J', 'P', 'G'),
        cv::CAP_PROP_FRAME_WIDTH, 1280,
        cv::CAP_PROP_FRAME_HEIGHT, 800,
        cv::CAP_PROP_FPS, 120,
        cv::CAP_PROP_BUFFERSIZE, 1
    };
    cap.open(camera_id, cv::CAP_V4L2, params);

    // 2. 运行时注入物理参数 (解锁 FPS + 提亮)
    std::string dev = "/dev/video" + std::to_string(camera_id);
    // 关自动曝光
    system(("v4l2-ctl -d " + dev + " -c auto_exposure=1").c_str());
    // 3ms 极短曝光 (解锁 120fps)
    system(("v4l2-ctl -d " + dev + " -c exposure_time_absolute=30").c_str());
    // 满增益 (提亮)
    system(("v4l2-ctl -d " + dev + " -c gain=200").c_str());
    
    return true;
}
```

### 2. `sample.cpp` (热成像配置)

C++

```
void load_stream_frame_info(StreamFrameInfo_t* stream_frame_info) {
    // 解除时间限制
    extern int stream_time;
    stream_time = 999999; 

    // 强制 YUV422 模式 + 伪彩开启
    stream_frame_info->image_info.pseudo_color_status = PSEUDO_COLOR_ON; 
    stream_frame_info->image_info.input_format = INPUT_FMT_YUV422; 
    stream_frame_info->image_info.output_format = OUTPUT_FMT_YUV422; 

    // 正确的内存分配 (2字节/像素)
    stream_frame_info->image_byte_size = stream_frame_info->image_info.width * stream_frame_info->image_info.height * 2;
    create_data_demo(stream_frame_info);
}
```

### 3. `main.cpp` (双机同步主循环)

C++

```
while (true) {
    // --- OV9281 (120FPS) ---
    if (ov_cam.getFrame(ov_raw)) {
        // ... FPS 计算与显示 ...
        cv::imshow("OV9281", ov_raw);
    }

    // --- 热成像 (30FPS, YUV->BGR) ---
    if (sem_trywait(&image_sem) == 0) {
        if (thermal_info.image_frame != NULL) {
            // 构造 YUV Mat
            ir_raw_yuv = cv::Mat(h, w, CV_8UC2, thermal_info.image_frame);
            // 转码为 BGR 显示，消除重影
            cv::cvtColor(ir_raw_yuv, ir_display_bgr, cv::COLOR_YUV2BGR_YUYV);
            cv::imshow("Thermal", ir_display_bgr);
        }
        sem_post(&image_done_sem); 
    }
    
    // 防卡死：必须清理温度信号
    if (sem_trywait(&temp_sem) == 0) sem_post(&temp_done_sem); 

    if (cv::waitKey(1) == 27) break; 
}
```

------

## 四、 编译与运行指南

### 1. 编译命令

在 `~/4D_System/build` 目录下：

Bash

```
rm -rf * cmake .. 
make -j4
```

### 2. 运行命令 (必须带环境变量)

为了确保 OpenCV 不会偷偷把格式改回 YUYV，必须加环境变量：

Bash

```
export DISPLAY=:0 
export OPENCV_VIDEOIO_V4L2_PIXEL_FORMAT=MJPG
sudo -E ./4D_System_Pi
```

### 3. 预期结果

- **终端输出**：`[Hardware] OV9281 FPS: 118.xx`。
- **屏幕显示**：
  - OV9281 窗口流畅显示（需强光照射）。
  - 热成像窗口显示彩色热图，无重影，不卡死。

------

## 五、 后续计划 

1. **Socket 推流**：目前是在树莓派本地显示，下一步需编写 TCP/UDP 发送端，将 120FPS 数据流直接发往 PC (RTX 3060)。
2. **时间戳同步**：在发送端为每一帧打上精确的微秒级时间戳，用于 4DGS 的时空对齐。